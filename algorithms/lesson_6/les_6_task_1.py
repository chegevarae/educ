'''
Подсчитать, сколько было выделено памяти под переменные в ранее разработанных 
программах в рамках первых трех уроков. Проанализировать результат и определить 
программы с наиболее эффективным использованием памяти.
Примечание: По аналогии с эмпирической оценкой алгоритмов идеальным решением будет:
a. выбрать хорошую задачу, которую имеет смысл оценивать по памяти;
b. написать 3 варианта кода (один у вас уже есть), проанализировать 3 варианта и выбрать оптимальный;
c. результаты анализа (количество занятой памяти в вашей среде разработки) вставить в виде 
комментариев в файл с кодом. Не забудьте указать версию и разрядность вашей ОС и интерпретатора Python;
d. написать общий вывод: какой из трёх вариантов лучше и почему.

Задача. Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,…
'''

import sys
import math as m

# Информация о системе:
print(f'Python: {sys.version}, {sys.platform}')
# Python 3.8.1 (tags/v3.8.1:1b293b6, Dec 18 2019, 23:11:46) [MSC v.1916 64 bit (AMD64)] on win32

# Количество элементов для подсчета их суммы:
n = 10

# Функция для определения размера объектов в памяти
def show_size(x):
    size = sys.getsizeof(x)
    print(f'type= {x.__class__}, size= {size}, object= {x}')
    if hasattr(x, '__iter__'):
        if hasattr(x, 'items'):
            for xx in x.items():
                print(f'\t type= {xx.__class__}, size= {sys.getsizeof(xx)}, object= {xx}')
        elif not isinstance(x, str):
            for xx in x:
                print(f'\t type= {xx.__class__}, size= {sys.getsizeof(xx)}, object= {xx}')
    return size

######################################################

# Вариант 1.
e = 1
s = 0
for i in range(n):
    s += e
    e /= -2
print(f'\nВариант 1. Сумма {n} элементов равна = {s}')

# Использование памяти:
result = show_size(n)
result += show_size(e)
result += show_size(s)
result += show_size(range(n))
print(f'Размер использованной памяти = {result} байт')

######################################################

# Вариант 2.
e = 1
lst = [1]
for i in range(1,n):
    e /= -2
    lst.append(e)
print(f'\nВариант 2. Сумма {n} элементов равна = {sum(lst)}')

# Использование памяти:
result = show_size(n)
result += show_size(e)
result += show_size(range(n))
result += show_size(lst)
print(f'Размер использованной памяти = {result} байт')

######################################################

# Вариант 3.
e = 1
lst = [1]
for i in range(1,n):
    e /= -2
    lst.append(e)
print(f'\nВариант 3. Сумма {n} элементов равна = {m.fsum(lst)}')

# Использование памяти:
result = show_size(n)
result += show_size(e)
result += show_size(range(n))
result += show_size(lst)
print(f'Размер использованной памяти = {result} байт')

######################################################

# ВЫВОД.
# Вариант 1 самый лучший с точки зрения использования ресурсов.
# Вариант 2 и 3, потребляют больше памяти из-за использования списков,
# при этом использование стороннего модуля math не замедляет работу программы,
# т.к. вычисление значения суммы зависит от размера массива, а не от функции суммы.
